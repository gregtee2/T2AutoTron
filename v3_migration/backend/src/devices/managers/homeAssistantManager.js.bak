const fetch = require('node-fetch');
const WebSocket = require('ws');
const logger = require('../../logging/logger');

class HomeAssistantManager {
  constructor() {
    this.devices = [];
    this.config = {
      host: process.env.HA_HOST || 'http://localhost:8123',
      token: process.env.HA_TOKEN,
    };
    this.ws = null;
  }

  async initialize(io, notificationEmitter, log) {
    try {
      await log('Initializing Home Assistant...', 'info', false, 'ha:init');
      const response = await fetch(`${this.config.host}/api/states`, {
        headers: { Authorization: `Bearer ${this.config.token}` },
      });
      if (!response.ok) throw new Error(`HA API error: ${response.status}: ${response.statusText}`);
      const states = await response.json();
      this.devices = states.filter(s => s.entity_id.startsWith('light.') || s.entity_id.startsWith('switch.'));
      await log(`Initialized ${this.devices.length} HA devices (light and switch)`, 'info', false, 'ha:initialized');

      if (io && notificationEmitter) {
        this.devices.forEach(device => {
          const state = {
            id: `ha_${device.entity_id}`,
            name: device.attributes.friendly_name || device.entity_id,
            type: device.entity_id.split('.')[0],
            on: device.state === 'on',
            brightness: device.attributes.brightness ? Math.round((device.attributes.brightness / 255) * 100) : (device.state === 'on' ? 100 : 0),
            hs_color: device.attributes.hs_color || [0, 0]
          };
          io.emit('device-state-update', state);
          notificationEmitter.emit('notify', `ðŸ”„ HA Update: ${state.name} is ${state.on ? 'ON' : 'OFF'}`);
        });

        // Initialize WebSocket for real-time updates
        this.ws = new WebSocket(`${this.config.host.replace('http', 'ws')}/api/websocket`);
        this.ws.on('open', () => {
          this.ws.send(JSON.stringify({ type: 'auth', access_token: this.config.token }));
          this.ws.send(JSON.stringify({ id: 1, type: 'subscribe_events', event_type: 'state_changed' }));
          log('HA WebSocket connected', 'info', false, 'ha:websocket');
        });
        this.ws.on('message', (data) => {
          try {
            const msg = JSON.parse(data);
            if (msg.type === 'event' && msg.event.event_type === 'state_changed') {
              const entity = msg.event.data.new_state;
              if (!entity || !(entity.entity_id.startsWith('light.') || entity.entity_id.startsWith('switch.'))) return;
              const state = {
                id: `ha_${entity.entity_id}`,
                on: entity.state === 'on',
                brightness: entity.attributes.brightness ? Math.round((entity.attributes.brightness / 255) * 100) : (entity.state === 'on' ? 100 : 0),
                hs_color: entity.attributes.hs_color || [0, 0]
              };
              io.emit('device-state-update', state);
              log(`HA state update: ${state.id} - ${entity.state}`, 'info', false, `ha:state:${state.id}`);
            }
          } catch (err) {
            log(`HA WebSocket message error: ${err.message}`, 'error', false, 'ha:websocket:message');
          }
        });
        this.ws.on('error', (err) => log(`HA WebSocket error: ${err.message}`, 'error', false, 'ha:websocket:error'));
        this.ws.on('close', () => log('HA WebSocket closed', 'warn', false, 'ha:websocket:close'));
      }
      return this.devices;
    } catch (error) {
      await log(`HA initialization failed: ${error.message}`, 'error', false, 'ha:error');
      return [];
    }
  }

  async getLightState(id) {
    try {
      const rawId = id.replace('ha_', '');
      const response = await fetch(`${this.config.host}/api/states/${rawId}`, {
        headers: { Authorization: `Bearer ${this.config.token}` },
        timeout: 5000
      });
      if (!response.ok) throw new Error(`HA API error: ${response.status}: ${response.statusText}`);
      const data = await response.json();
      const state = {
        on: data.state === 'on',
        brightness: data.attributes.brightness ? Math.round((data.attributes.brightness / 255) * 100) : (data.state === 'on' ? 100 : 0),
        hs_color: data.attributes.hs_color || [0, 0]
      };
      await logger.log(`Fetched state for HA device ${rawId}: on=${state.on}, brightness=${state.brightness}, hs_color=${JSON.stringify(state.hs_color)}`, 'info', false, `ha:state:${rawId}`);
      return { success: true, state };
    } catch (error) {
      await logger.log(`Failed to fetch state for HA device ${id}: ${error.message}`, 'error', false, `ha:state:${id}`);
      return { success: false, error: error.message };
    }
  }

  async controlDevice(id, state) {
    try {
      const rawId = id.replace('ha_', '');
      const entityType = rawId.split('.')[0];
      const service = entityType === 'light' ? 'light' : 'switch';
      const payload = { entity_id: rawId };
      if (state.on) {
        if (state.brightness !== undefined) payload.brightness_pct = Math.round(state.brightness);
        if (state.hs_color) payload.hs_color = state.hs_color;
        if (state.transition !== undefined) payload.transition = state.transition / 1000;
      }
      const response = await fetch(`${this.config.host}/api/services/${service}/${state.on ? 'turn_on' : 'turn_off'}`, {
        method: 'POST',
        headers: {
          Authorization: `Bearer ${this.config.token}`,
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(payload),
        timeout: 5000
      });
      if (!response.ok) {
        const errorBody = await response.text();
        throw new Error(`HA API error: ${response.status}: ${response.statusText}, Body: ${errorBody}`);
      }
      await logger.log(`HA control succeeded for ${id}: ${JSON.stringify(payload)}`, 'info', false, `ha:control:${id}`);
      return { success: true };
    } catch (error) {
      await logger.log(`HA control failed for ${id}: ${error.message}`, 'error', false, `ha:error:${id}`);
      return { success: false, error: error.message };
    }
  }

  async updateLightState(id, update) {
    try {
      const rawId = id.replace('ha_', '');
      const entityType = rawId.split('.')[0];
      const service = entityType === 'light' ? 'light' : 'switch';
      const payload = { entity_id: rawId };
      if (update.on) {
        if (update.brightness !== undefined) payload.brightness_pct = Math.round(update.brightness);
        if (update.hs_color) payload.hs_color = update.hs_color;
        if (update.transition !== undefined) payload.transition = update.transition / 1000;
      }
      await logger.log(`Sending HA state update for ${id}: ${JSON.stringify(payload)}`, 'info', false, `ha:state:${id}`);
      const response = await fetch(`${this.config.host}/api/services/${service}/${update.on ? 'turn_on' : 'turn_off'}`, {
        method: 'POST',
        headers: {
          Authorization: `Bearer ${this.config.token}`,
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(payload),
        timeout: 5000
      });
      if (!response.ok) {
        const errorBody = await response.text();
        throw new Error(`HA API error: ${response.status}: ${response.statusText}, Body: ${errorBody}`);
      }
      await logger.log(`HA state update succeeded for ${id}: ${JSON.stringify(payload)}`, 'info', false, `ha:state:${id}`);
      return { success: true };
    } catch (error) {
      await logger.log(`HA state update failed for ${id}: ${error.message}`, 'error', false, `ha:state:${id}`);
      return { success: false, error: error.message };
    }
  }

  getDevices() {
    return this.devices.map(device => ({
      id: `ha_${device.entity_id}`,
      name: device.attributes.friendly_name || device.entity_id,
      type: device.entity_id.split('.')[0],
      state: {
        on: device.state === 'on',
        brightness: device.attributes.brightness ? Math.round((device.attributes.brightness / 255) * 100) : (device.state === 'on' ? 100 : 0),
        hs_color: device.attributes.hs_color || [0, 0]
      }
    }));
  }

  // Cleanup WebSocket on shutdown
  shutdown() {
    if (this.ws) {
      this.ws.close();
      this.ws = null;
    }
  }
}

module.exports = new HomeAssistantManager();