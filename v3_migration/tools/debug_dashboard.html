<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>T2AutoTron Debug</title>
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #1a1a2e;
            color: #eee;
            padding: 20px;
        }
        h1 { color: #00d4ff; margin-bottom: 5px; }
        .subtitle { color: #666; font-size: 14px; margin-bottom: 20px; }
        
        .config-bar {
            background: #252540;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            display: flex;
            gap: 15px;
            align-items: center;
            flex-wrap: wrap;
        }
        .config-bar input {
            background: #1a1a2e;
            border: 1px solid #444;
            color: #eee;
            padding: 10px 15px;
            border-radius: 6px;
            width: 350px;
            font-size: 14px;
        }
        .config-bar button {
            background: #00d4ff;
            color: #000;
            border: none;
            padding: 10px 25px;
            border-radius: 6px;
            cursor: pointer;
            font-weight: bold;
        }
        .config-bar button:hover { background: #00b8e6; }
        .config-bar button.secondary {
            background: #444;
            color: #eee;
        }
        .config-bar button.secondary:hover { background: #555; }
        .status { 
            padding: 8px 15px; 
            border-radius: 6px; 
            font-size: 13px;
        }
        .status.connected { background: #1b5e20; color: #81c784; }
        .status.error { background: #4a1010; color: #e57373; }
        .status.loading { background: #333; color: #888; }
        
        .dashboard {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
            gap: 20px;
        }
        .panel {
            background: #252540;
            border-radius: 12px;
            padding: 20px;
        }
        .panel.full-width {
            grid-column: 1 / -1;
        }
        .panel-title {
            font-size: 16px;
            font-weight: 600;
            color: #00d4ff;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid #333;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .panel-title .badge {
            font-size: 11px;
            padding: 3px 8px;
            border-radius: 10px;
            background: #333;
        }
        .panel-title .badge.warning { background: #ff9800; color: #000; }
        .panel-title .badge.success { background: #4caf50; color: #000; }
        
        /* Engine stats */
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
        }
        .stat {
            background: #1a1a2e;
            padding: 15px;
            border-radius: 8px;
            text-align: center;
        }
        .stat-value { font-size: 24px; font-weight: bold; color: #00d4ff; }
        .stat-label { font-size: 11px; color: #666; margin-top: 5px; }
        
        /* Light list */
        .light-list { max-height: 400px; overflow-y: auto; }
        .light-item {
            display: flex;
            align-items: center;
            padding: 10px;
            margin-bottom: 8px;
            background: #1a1a2e;
            border-radius: 8px;
            gap: 12px;
        }
        .light-color {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            border: 2px solid #444;
        }
        .light-info { flex: 1; }
        .light-name { font-size: 13px; font-weight: 500; }
        .light-details { font-size: 11px; color: #888; margin-top: 3px; }
        .light-state {
            font-size: 11px;
            padding: 4px 8px;
            border-radius: 4px;
            text-transform: uppercase;
        }
        .light-state.on { background: #1b5e20; color: #81c784; }
        .light-state.off { background: #333; color: #666; }
        
        /* Buffer list */
        .buffer-list { max-height: 350px; overflow-y: auto; }
        .buffer-item {
            display: flex;
            align-items: center;
            padding: 8px 12px;
            margin-bottom: 6px;
            background: #1a1a2e;
            border-radius: 6px;
            gap: 10px;
        }
        .buffer-color {
            width: 20px;
            height: 20px;
            border-radius: 4px;
            border: 1px solid #444;
        }
        .buffer-name { flex: 1; font-size: 12px; }
        .buffer-value { font-size: 11px; color: #00d4ff; font-family: monospace; }
        
        /* Event Log */
        .event-log { max-height: 400px; overflow-y: auto; }
        .event-item {
            display: flex;
            align-items: flex-start;
            padding: 8px 12px;
            margin-bottom: 6px;
            background: #1a1a2e;
            border-radius: 6px;
            gap: 10px;
            font-size: 12px;
        }
        .event-time { color: #666; font-family: monospace; white-space: nowrap; }
        .event-entity { color: #00d4ff; font-weight: 500; flex-shrink: 0; }
        .event-action { flex: 1; }
        .event-action.on { color: #81c784; }
        .event-action.off { color: #e57373; }
        .event-action.trigger { color: #ffb74d; }
        
        /* Comparison panel */
        .comparison-list { max-height: 500px; overflow-y: auto; }
        .comparison-item {
            padding: 12px;
            margin-bottom: 8px;
            background: #1a1a2e;
            border-radius: 8px;
            border-left: 4px solid #444;
        }
        .comparison-item.match { border-left-color: #4caf50; }
        .comparison-item.mismatch { 
            border-left-color: #f44336; 
            background: #3a1515 !important;
            animation: bugPulse 2s infinite;
        }
        .comparison-item.unknown { border-left-color: #ff9800; }
        @keyframes bugPulse {
            0%, 100% { box-shadow: 0 0 0 0 rgba(244, 67, 54, 0.4); }
            50% { box-shadow: 0 0 8px 2px rgba(244, 67, 54, 0.6); }
        }
        .comparison-header {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
        }
        .comparison-entity { color: #00d4ff; font-weight: 500; }
        .comparison-status { font-size: 12px; padding: 2px 8px; border-radius: 4px; }
        .comparison-status.match { background: #1b5e20; color: #81c784; }
        .comparison-status.mismatch { background: #b71c1c; color: #fff; font-weight: bold; }
        .comparison-status.unknown { background: #4a3000; color: #ffb74d; }
        .comparison-details {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            font-size: 12px;
        }
        .comparison-col { padding: 8px; background: #252540; border-radius: 4px; }
        .comparison-col-title { color: #888; margin-bottom: 5px; font-size: 11px; }
        
        .no-data { color: #666; text-align: center; padding: 20px; font-style: italic; }
        .last-update { font-size: 11px; color: #444; margin-top: 10px; text-align: right; }
        
        .filter-input {
            background: #1a1a2e;
            border: 1px solid #333;
            color: #eee;
            padding: 6px 10px;
            border-radius: 4px;
            font-size: 12px;
            width: 100%;
            margin-bottom: 10px;
        }
        
        .tabs {
            display: flex;
            gap: 5px;
            margin-bottom: 15px;
        }
        .tab {
            padding: 8px 16px;
            background: #1a1a2e;
            border: none;
            color: #888;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
        }
        .tab.active { background: #00d4ff; color: #000; }
        .tab:hover:not(.active) { background: #333; }
        
        .hours-selector {
            display: flex;
            gap: 5px;
            margin-bottom: 10px;
        }
        .hours-btn {
            padding: 4px 10px;
            background: #333;
            border: none;
            color: #888;
            border-radius: 4px;
            cursor: pointer;
            font-size: 11px;
        }
        .hours-btn.active { background: #00d4ff; color: #000; }
    </style>
</head>
<body>
    <h1>üîß T2AutoTron Debug Dashboard</h1>
    <p class="subtitle">Real-time monitoring & Event Analysis - No login required</p>
    
    <div class="config-bar">
        <input type="text" id="backendUrl" placeholder="T2AutoTron Backend URL (e.g., http://192.168.1.100:3000)">
        <button onclick="connect()">Connect</button>
        <button class="secondary" onclick="loadEventLog()">üìã Load Event Log</button>
        <button class="secondary" onclick="runComparison()">üîç Compare Graph vs Reality</button>
        <span class="status loading" id="status">Not connected</span>
    </div>
    
    <div class="dashboard">
        <!-- Engine Status -->
        <div class="panel">
            <div class="panel-title">‚öôÔ∏è Engine Status</div>
            <div class="stats-grid">
                <div class="stat">
                    <div class="stat-value" id="engineRunning">--</div>
                    <div class="stat-label">Status</div>
                </div>
                <div class="stat">
                    <div class="stat-value" id="engineNodes">--</div>
                    <div class="stat-label">Nodes</div>
                </div>
                <div class="stat">
                    <div class="stat-value" id="engineTicks">--</div>
                    <div class="stat-label">Ticks</div>
                </div>
                <div class="stat">
                    <div class="stat-value" id="engineUptime">--</div>
                    <div class="stat-label">Uptime (min)</div>
                </div>
            </div>
        </div>
        
        <!-- Buffers -->
        <div class="panel">
            <div class="panel-title">üì¶ Active Buffers (Sender/Receiver)</div>
            <input type="text" class="filter-input" id="bufferFilter" placeholder="Filter..." oninput="renderBuffers()">
            <div class="buffer-list" id="bufferList">
                <div class="no-data">Connect to view buffers</div>
            </div>
        </div>
        
        <!-- Event Log -->
        <div class="panel">
            <div class="panel-title">
                üìã Event Log (On/Off Only)
                <span class="badge" id="eventCount">0 events</span>
            </div>
            <div class="hours-selector">
                <button class="hours-btn active" onclick="setHours(1)">1h</button>
                <button class="hours-btn" onclick="setHours(6)">6h</button>
                <button class="hours-btn" onclick="setHours(12)">12h</button>
                <button class="hours-btn" onclick="setHours(24)">24h</button>
            </div>
            <input type="text" class="filter-input" id="eventFilter" placeholder="Filter by entity..." oninput="renderEventLog()">
            <div class="event-log" id="eventLog">
                <div class="no-data">Click "Load Event Log" to fetch events</div>
            </div>
        </div>
        
        <!-- Graph vs Reality Comparison -->
        <div class="panel">
            <div class="panel-title">
                üîç Graph vs Reality
                <span class="badge" id="comparisonBadge">--</span>
            </div>
            <div class="comparison-list" id="comparisonList">
                <div class="no-data">Click "Compare Graph vs Reality" to analyze</div>
            </div>
        </div>
        
        <!-- Lights -->
        <div class="panel full-width">
            <div class="panel-title">üí° Light States</div>
            <input type="text" class="filter-input" id="lightFilter" placeholder="Filter lights..." oninput="renderLights()">
            <div class="light-list" id="lightList">
                <div class="no-data">Connect to view lights</div>
            </div>
            <div class="last-update" id="lastUpdate"></div>
        </div>
    </div>

    <script>
        let data = { engine: {}, buffers: {}, lights: [] };
        let eventLogData = [];
        let graphData = null;
        let selectedHours = 1;
        let refreshInterval = null;
        
        // Load saved URL
        const savedUrl = localStorage.getItem('t2debug_url');
        if (savedUrl) document.getElementById('backendUrl').value = savedUrl;
        
        function hsToRgb(h, s) {
            h = (h || 0) / 360;
            s = (s || 0) / 100;
            const v = 1;
            let r, g, b;
            const i = Math.floor(h * 6);
            const f = h * 6 - i;
            const p = v * (1 - s);
            const q = v * (1 - f * s);
            const t = v * (1 - (1 - f) * s);
            switch (i % 6) {
                case 0: r = v; g = t; b = p; break;
                case 1: r = q; g = v; b = p; break;
                case 2: r = p; g = v; b = t; break;
                case 3: r = p; g = q; b = v; break;
                case 4: r = t; g = p; b = v; break;
                case 5: r = v; g = p; b = q; break;
            }
            return `rgb(${Math.round(r * 255)}, ${Math.round(g * 255)}, ${Math.round(b * 255)})`;
        }
        
        function hueToRgb(hue) {
            return hsToRgb(hue * 360, 100);
        }
        
        function setHours(h) {
            selectedHours = h;
            document.querySelectorAll('.hours-btn').forEach(btn => btn.classList.remove('active'));
            event.target.classList.add('active');
            loadEventLog();
        }
        
        async function connect() {
            const url = document.getElementById('backendUrl').value.trim();
            if (!url) {
                alert('Please enter the T2AutoTron backend URL');
                return;
            }
            localStorage.setItem('t2debug_url', url);
            
            document.getElementById('status').className = 'status loading';
            document.getElementById('status').textContent = 'Connecting...';
            
            await refresh();
            
            if (refreshInterval) clearInterval(refreshInterval);
            refreshInterval = setInterval(refresh, 3000);
        }
        
        async function refresh() {
            const url = document.getElementById('backendUrl').value.trim();
            if (!url) return;
            
            try {
                const response = await fetch(`${url}/api/debug/all`);
                data = await response.json();
                
                if (data.success) {
                    document.getElementById('status').className = 'status connected';
                    document.getElementById('status').textContent = '‚úì Connected';
                    
                    renderEngine();
                    renderBuffers();
                    renderLights();
                    
                    document.getElementById('lastUpdate').textContent = `Last updated: ${new Date().toLocaleTimeString()}`;
                } else {
                    throw new Error(data.error || 'Unknown error');
                }
            } catch (err) {
                document.getElementById('status').className = 'status error';
                document.getElementById('status').textContent = `‚úó ${err.message}`;
            }
        }
        
        async function loadEventLog() {
            const url = document.getElementById('backendUrl').value.trim();
            if (!url) {
                alert('Please enter the backend URL first');
                return;
            }
            
            try {
                // Fetch device history (on/off events only)
                const response = await fetch(`${url}/api/engine/logs/device-history?hours=${selectedHours}`);
                const result = await response.json();
                
                if (result.success) {
                    // Filter to only on/off events (not HSV changes)
                    eventLogData = (result.history || []).filter(event => {
                        const action = (event.action || '').toLowerCase();
                        return action.includes('turn_on') || action.includes('turn_off') || 
                               action.includes('‚Üí true') || action.includes('‚Üí false') ||
                               event.category === 'TRIGGER';
                    });
                    renderEventLog();
                    document.getElementById('eventCount').textContent = `${eventLogData.length} events`;
                } else {
                    throw new Error(result.error || 'Failed to load events');
                }
            } catch (err) {
                document.getElementById('eventLog').innerHTML = `<div class="no-data">Error: ${err.message}</div>`;
            }
        }
        
        function renderEventLog() {
            const filter = document.getElementById('eventFilter').value.toLowerCase();
            const events = eventLogData.filter(e => 
                !filter || (e.entity || '').toLowerCase().includes(filter) || 
                (e.action || '').toLowerCase().includes(filter)
            );
            
            if (events.length === 0) {
                document.getElementById('eventLog').innerHTML = '<div class="no-data">No on/off events found</div>';
                return;
            }
            
            // Show most recent first
            const html = events.slice().reverse().map(event => {
                const time = new Date(event.time).toLocaleTimeString();
                const entity = (event.entity || 'unknown').replace('light.', '').replace('switch.', '');
                const action = event.action || '';
                
                let actionClass = '';
                let actionText = action;
                if (action.includes('turn_on') || action.includes('‚Üí true')) {
                    actionClass = 'on';
                    actionText = 'üü¢ ON';
                } else if (action.includes('turn_off') || action.includes('‚Üí false')) {
                    actionClass = 'off';
                    actionText = 'üî¥ OFF';
                } else if (event.category === 'TRIGGER') {
                    actionClass = 'trigger';
                    actionText = `‚ö° ${action}`;
                }
                
                return `
                    <div class="event-item">
                        <span class="event-time">${time}</span>
                        <span class="event-entity">${entity}</span>
                        <span class="event-action ${actionClass}">${actionText}</span>
                    </div>
                `;
            }).join('');
            
            document.getElementById('eventLog').innerHTML = html;
        }
        
        async function runComparison() {
            const url = document.getElementById('backendUrl').value.trim();
            if (!url) {
                alert('Please enter the backend URL first');
                return;
            }
            
            try {
                // Fetch graph data and event log
                const [graphResponse, eventsResponse, buffersResponse] = await Promise.all([
                    fetch(`${url}/api/engine/last-active`).catch(() => ({ ok: false })),
                    fetch(`${url}/api/engine/logs/device-history?hours=${selectedHours}`),
                    fetch(`${url}/api/debug/all`)
                ]);
                
                let graphNodes = [];
                if (graphResponse.ok) {
                    const graphResult = await graphResponse.json();
                    // Graph data is inside .graph property from /api/engine/last-active
                    const graphData = graphResult.graph || graphResult;
                    graphNodes = graphData.nodes || [];
                    console.log('Loaded graph with', graphNodes.length, 'nodes');
                }
                
                const eventsResult = await eventsResponse.json();
                const buffersResult = await buffersResponse.json();
                
                // Extract trigger buffers and their current values
                const triggerBuffers = {};
                if (buffersResult.buffers) {
                    Object.entries(buffersResult.buffers).forEach(([name, value]) => {
                        if (name.startsWith('[Trigger]')) {
                            triggerBuffers[name] = value;
                        }
                    });
                }
                
                // Extract device nodes and their configurations
                const deviceNodes = [];
                graphNodes.forEach(node => {
                    const data = node.data || {};
                    const props = data.properties || {};
                    // Check both node.label and data.label for compatibility
                    const nodeLabel = node.label || data.label;
                    
                    if (nodeLabel === 'HA Generic Device') {
                        (props.selectedDeviceIds || []).forEach((deviceId, i) => {
                            deviceNodes.push({
                                nodeId: node.id,
                                nodeTitle: props.customTitle || nodeLabel,
                                deviceId: deviceId,
                                deviceName: (props.selectedDeviceNames || [])[i] || deviceId,
                                triggerMode: props.triggerMode || 'Follow'
                            });
                        });
                    }
                });
                
                console.log('Found', deviceNodes.length, 'HA devices in graph');
                
                // Find events for each device
                const events = eventsResult.history || [];
                const comparison = deviceNodes.map(node => {
                    const entityId = node.deviceId.replace('ha_', '');
                    const entityShort = entityId.split('.')[1];
                    
                    // Find ALL events for this device (on/off commands)
                    const deviceEvents = events.filter(e => 
                        e.entity && e.entity.includes(entityShort)
                    );
                    
                    // Find only ON and OFF commands
                    const onOffEvents = deviceEvents.filter(e => 
                        e.action?.includes('turn_on') || e.action?.includes('turn_off')
                    );
                    
                    const lastOnEvent = onOffEvents.filter(e => e.action?.includes('turn_on')).slice(-1)[0];
                    const lastOffEvent = onOffEvents.filter(e => e.action?.includes('turn_off')).slice(-1)[0];
                    
                    // Get current state from lights list
                    const light = (buffersResult.lights || []).find(l => l.id === node.deviceId);
                    const currentState = light?.state?.on ? 'on' : 'off';
                    
                    // Determine what the log says should be the state
                    let loggedState = 'unknown';
                    if (lastOnEvent && lastOffEvent) {
                        // Both exist - which was more recent?
                        const onTime = new Date(lastOnEvent.time).getTime();
                        const offTime = new Date(lastOffEvent.time).getTime();
                        loggedState = onTime > offTime ? 'on' : 'off';
                    } else if (lastOnEvent) {
                        loggedState = 'on';
                    } else if (lastOffEvent) {
                        loggedState = 'off';
                    }
                    
                    return {
                        ...node,
                        eventCount: onOffEvents.length,
                        lastOnEvent,
                        lastOffEvent,
                        loggedState,
                        currentState
                    };
                });
                
                renderComparison(comparison, triggerBuffers);
                
            } catch (err) {
                document.getElementById('comparisonList').innerHTML = `<div class="no-data">Error: ${err.message}</div>`;
            }
        }
        
        function renderComparison(comparison, triggerBuffers) {
            if (comparison.length === 0) {
                document.getElementById('comparisonList').innerHTML = '<div class="no-data">No device nodes found in graph</div>';
                document.getElementById('comparisonBadge').textContent = '0 devices';
                return;
            }
            
            // Count issues
            let bugs = 0;
            let ok = 0;
            let noEvents = 0;
            
            const html = comparison.map(item => {
                // THE KEY LOGIC:
                // BUG = Device state doesn't match what we commanded
                // If OFF but no OFF command logged = something external turned it off
                // If ON but no ON command logged = something external turned it on
                
                let status = 'match';
                let statusText = '‚úì OK';
                let statusEmoji = '‚úÖ';
                let explanation = '';
                
                if (item.currentState === 'off' && !item.lastOffEvent && item.eventCount > 0) {
                    // üêõ BUG: Device is OFF but we only sent ON commands!
                    status = 'mismatch';
                    statusText = 'üêõ BUG!';
                    statusEmoji = 'üêõ';
                    explanation = 'Device is OFF but no OFF command was logged!';
                    bugs++;
                } else if (item.currentState === 'on' && !item.lastOnEvent && item.eventCount > 0) {
                    // üêõ BUG: Device is ON but we only sent OFF commands!
                    status = 'mismatch';
                    statusText = 'üêõ BUG!';
                    statusEmoji = 'üêõ';
                    explanation = 'Device is ON but no ON command was logged!';
                    bugs++;
                } else if (item.eventCount === 0) {
                    // No events at all - device was in this state before logging window
                    status = 'unknown';
                    statusText = 'No events';
                    statusEmoji = 'üí§';
                    explanation = 'No commands logged in this time window';
                    noEvents++;
                } else if (item.eventCount > 0) {
                    // We have events and state matches what we expect
                    if (item.currentState === item.loggedState) {
                        status = 'match';
                        statusText = '‚úì OK';
                        statusEmoji = '‚úÖ';
                        explanation = `Last logged: ${item.loggedState.toUpperCase()}, Current: ${item.currentState.toUpperCase()}`;
                        ok++;
                    } else {
                        // State doesn't match last logged command - something external changed it
                        status = 'mismatch';
                        statusText = '‚ö†Ô∏è Changed';
                        statusEmoji = '‚ö†Ô∏è';
                        explanation = `Logged: ${item.loggedState.toUpperCase()}, but now: ${item.currentState.toUpperCase()}`;
                        bugs++;
                    }
                } else {
                    status = 'unknown';
                    statusText = 'Idle';
                    statusEmoji = 'üí§';
                    explanation = 'No commands sent';
                    noEvents++;
                }
                
                const lastOnTime = item.lastOnEvent ? new Date(item.lastOnEvent.time).toLocaleTimeString() : '--';
                const lastOffTime = item.lastOffEvent ? new Date(item.lastOffEvent.time).toLocaleTimeString() : '--';
                
                return `
                    <div class="comparison-item ${status}">
                        <div class="comparison-header">
                            <span class="comparison-entity">${statusEmoji} ${item.nodeTitle || item.deviceName}</span>
                            <span class="comparison-status ${status}">${statusText}</span>
                        </div>
                        <div style="font-size: 11px; color: ${status === 'mismatch' ? '#ff6b6b' : '#888'}; margin-bottom: 8px;">
                            ${explanation}
                        </div>
                        <div class="comparison-details">
                            <div class="comparison-col">
                                <div class="comparison-col-title">Current State</div>
                                <span style="color: ${item.currentState === 'on' ? '#81c784' : '#e57373'}; font-weight: bold;">
                                    ${item.currentState.toUpperCase()}
                                </span><br>
                                Entity: ${item.deviceId.replace('ha_', '').split('.')[1]}
                            </div>
                            <div class="comparison-col">
                                <div class="comparison-col-title">Last Logged Commands</div>
                                üü¢ ON: ${lastOnTime}<br>
                                üî¥ OFF: ${lastOffTime}
                            </div>
                        </div>
                    </div>
                `;
            }).join('');
            
            document.getElementById('comparisonList').innerHTML = html;
            
            // Update badge
            if (bugs > 0) {
                document.getElementById('comparisonBadge').className = 'badge warning';
                document.getElementById('comparisonBadge').textContent = `üêõ ${bugs} BUGS found!`;
            } else if (ok > 0) {
                document.getElementById('comparisonBadge').className = 'badge success';
                document.getElementById('comparisonBadge').textContent = `‚úÖ ${ok} OK, ${noEvents} idle`;
            } else {
                document.getElementById('comparisonBadge').className = 'badge';
                document.getElementById('comparisonBadge').textContent = `${noEvents} devices, no events`;
            }
        }
        
        function renderEngine() {
            const e = data.engine || {};
            document.getElementById('engineRunning').textContent = e.running ? 'üü¢ ON' : '‚ö´ OFF';
            document.getElementById('engineNodes').textContent = e.nodeCount || 0;
            document.getElementById('engineTicks').textContent = (e.tickCount || 0).toLocaleString();
            document.getElementById('engineUptime').textContent = Math.floor((e.uptime || 0) / 60000);
        }
        
        function renderBuffers() {
            const filter = document.getElementById('bufferFilter').value.toLowerCase();
            const buffers = data.buffers || {};
            const entries = Object.entries(buffers).filter(([k]) => k.toLowerCase().includes(filter));
            
            if (entries.length === 0) {
                document.getElementById('bufferList').innerHTML = '<div class="no-data">No buffers</div>';
                return;
            }
            
            const html = entries.map(([name, value]) => {
                let displayValue = '';
                let colorBox = '';
                
                if (value && typeof value === 'object' && 'hue' in value) {
                    colorBox = `<div class="buffer-color" style="background: ${hueToRgb(value.hue)}"></div>`;
                    displayValue = `H:${(value.hue || 0).toFixed(3)} S:${(value.saturation || 0).toFixed(2)} B:${value.brightness || 0}`;
                } else if (typeof value === 'boolean') {
                    colorBox = `<div class="buffer-color" style="background: ${value ? '#4caf50' : '#333'}"></div>`;
                    displayValue = value ? 'TRUE' : 'FALSE';
                } else if (typeof value === 'number') {
                    displayValue = value.toFixed(2);
                } else {
                    displayValue = JSON.stringify(value).slice(0, 40);
                }
                
                return `<div class="buffer-item">${colorBox}<div class="buffer-name">${name}</div><div class="buffer-value">${displayValue}</div></div>`;
            }).join('');
            
            document.getElementById('bufferList').innerHTML = html;
        }
        
        function renderLights() {
            const filter = document.getElementById('lightFilter').value.toLowerCase();
            const lights = (data.lights || []).filter(l => 
                (l.id || '').toLowerCase().includes(filter) || 
                (l.name || '').toLowerCase().includes(filter)
            );
            
            if (lights.length === 0) {
                document.getElementById('lightList').innerHTML = '<div class="no-data">No lights found</div>';
                return;
            }
            
            const html = lights.map(light => {
                // light.state is an object: { state: 'on', on: true, brightness: 100, hs_color: [h, s] }
                const stateObj = light.state || {};
                const stateStr = stateObj.state || 'off';
                const isOn = stateObj.on || stateStr === 'on';
                
                // Get hs_color from state object, fallback to attributes
                const hs = stateObj.hs_color || light.attributes?.hs_color || [0, 0];
                
                // Get brightness (state obj has it as 0-100 percentage, attributes has 0-255)
                let brightness = 0;
                if (stateObj.brightness !== undefined) {
                    // State obj brightness is 0-100 percentage, convert to 0-255 for display consistency
                    brightness = Math.round(stateObj.brightness * 2.55);
                } else if (light.attributes?.brightness !== undefined) {
                    brightness = light.attributes.brightness;
                }
                
                // Show actual light color when on, gray when off
                const color = isOn ? hsToRgb(hs[0], hs[1]) : '#444';
                // Use brightness to dim the color (but keep minimum visible)
                const colorOpacity = isOn ? Math.max(0.4, brightness / 255) : 0.3;
                const name = light.name || light.id?.replace('ha_light.', '') || 'Unknown';
                
                // Border glow effect for "on" lights
                const glowStyle = isOn ? `box-shadow: 0 0 8px ${color};` : '';
                
                return `
                    <div class="light-item">
                        <div class="light-color" style="background: ${color}; opacity: ${colorOpacity}; ${glowStyle}"></div>
                        <div class="light-info">
                            <div class="light-name">${name}</div>
                            <div class="light-details">H: ${hs[0]?.toFixed(0) || '--'}¬∞ S: ${hs[1]?.toFixed(0) || '--'}% B: ${brightness || '--'}</div>
                        </div>
                        <div class="light-state ${isOn ? 'on' : 'off'}">${stateStr}</div>
                    </div>
                `;
            }).join('');
            
            document.getElementById('lightList').innerHTML = html;
        }
        
        // Auto-connect if URL is saved
        if (savedUrl) {
            setTimeout(connect, 500);
        }
    </script>
</body>
</html>
